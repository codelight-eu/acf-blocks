# ACF Blocks
ACF Blocks is a lightweight library that provides a clean, object-oriented API to create and render ACF field groups. 

Your WordPress code base doesn't have to be a mess.

## Overview
ACF Blocks introduces the concept of *blocks*, which are essentially Controllers for field groups and flexible layouts. Fields are created using the excellent [ACF Builder](https://github.com/StoutLogic/acf-builder) library. 

The three main benefits of using ACF blocks are:
- Speed up development of simple sites,
- Provide a super simple, but clean architecture for developing more complex sites,
- Allow re-using blocks between projects.

## Installation
In your composer.json file:
```
"repositories": [
    {
      "url": "git@github.com:codelight-eu/acf-blocks.git",
      "type": "git"
    }
],
"require": {
  "codelight/acf-blocks": "dev-master"
}
```

Once this repo is published, you'll be able to simply do this:
```
composer require codelight/acf-blocks
```
If you're still not using Composer in 2017, then do yourself a **huge** favor and get started now. [todo: article] 

## Example 1: Quick procedural blocks
As an example, let's go through creating and rendering a simple field group.
```php
<?php
// blocks.php

use Codelight\ACFBlocks\Blocks;
use Codelight\ACFBlocks\BlockType;

add_action('init', function() {

    // Create a new block
    $imageBlock = new BlockType('example_image');
    
    /**
     * Define ACF fields - see https://github.com/StoutLogic/acf-builder
     * Add an image field and a wysiwyg field.
     * Also add the field group to template-image.php page template
     */
    $imageBlock->getFieldsBuilder()
        ->addImage('awesome_image', ['return_format' => 'id'])
        ->addWysiwyg('boring_text')
        ->setLocation('page_template', '==', 'template-image.php');
    
    /**
     * Add a function for processing raw ACF data before it's sent to the template.
     * This allows you to do additional processing depending on the data and keep your templates clean.
     */
    $imageBlock->addCallback(function($data) {
    
        // Return the full image html with srcset attribute generated by wordpress
        $data['image'] = wp_get_attachment_image($data['awesome_image'], 'large');
        
        // Split the wysiwyg contents into an excerpt and the full text
        $data['excerpt'] = wp_trim_words($data['boring_text'], 25);
        $data['text'] = $data['boring_text'];
        
        return $data;
    });
    
    // Set the template for this block
    $imageBlock->setTemplate('templates/blocks/image.php');
    
    // Register the block with the main block manager class
    $blocks = Blocks::getInstance();
    $blocks->registerBlock($imageBlock);
}
```
```php
<?php
// template-image.php
/**
 * Template name: Image
 *
 * This is the page template where we will be rendering our block.
 * Calling `blocks()->get()` inside the Loop will return all pre-rendered blocks 
 * assigned to that specific page or post.
 */
?>
<?php while (have_posts()) : the_post(); ?>
    <?php foreach (blocks()->get() as $block): ?>
        <?= $block; ?>
    <?php endforeach; ?>
<?php endwhile; ?>
```
```php
<?php
// templates/blocks/image.php
/**
 * This is the template of the single block.
 * Data is injected automatically.
 */
?>
<section class="section-image">
    <?= $image; ?>
    <div class="description">
        <div class="description-excerpt">
            <?= $excerpt; ?>
        </div>
        <div class="description-full">
            <?= $text; ?>
        </div>
    </div>
</section>
```

## Example 2: Encapsulate the block in a class
Let's create the same block in a much cleaner way - as a class. This class should be in a separate file called ImageBlock.php. You'll probably want to keep it in a separate folder, which you might want to call 'blocks'.
```php
<?php
use Codelight\ACFBlocks\BlockType;

class ImageBlock extends BlockType {

    protected $config = [
        // The machine-readable name of the block
        'name' => 'example_image';
        // The location of the template
        'template' => 'templates/blocks/image.php',
    ];

    // This function is called when the block type is initialized for the first time.
    // You'll use it mostly to register the fields
    public function init()
    {
        $this->getFieldsBuilder()
            ->addImage('awesome_image', ['return_format' => 'id'])
            ->addWysiwyg('boring_text')
            ->setLocation('page_template', '==', 'template-image.php');
    }
    
    // This function works in a similar way to addCallback() - it allows you to
    // modify the data that's passed into the template
    public function filterData($data)
    {
        // Return the full image html with srcset attribute generated by wordpress
        $data['image'] = wp_get_attachment_image($data['awesome_image'], 'large');
        
        // Split the wysiwyg contents into an excerpt and the full text
        $data['excerpt'] = wp_trim_words($data['boring_text'], 25);
        $data['text'] = $data['boring_text'];
        
        return $data;
    }
}
```

We'll also need to register the block we just created. This goes into your functions.php (or equivalent):
```php
<?php
require_once('blocks/ImageBlock.php');

add_action('init', function() {
    $blocks = Blocks::getInstance();
    $blocks->init([
        'blocktypes' => [
            // array of block class names as strings
            'ImageBlock',
        ]
    ]);
});
```

And that's it. You'll also need to add the templates as in the previous example.

## Example 3: Setting up flexible layouts
Let's continue the previous example, but register the ImageBlock as a Flexible Content layout.  
First, we'll need to create the Flexible Content block which will contain our ImageBlock.
```php
<?php
use Codelight\ACFBlocks\FlexibleContentBlockType;

class FlexibleBlock extends FlexibleContentBlockType
{
    protected $config = [
        // The machine-readable name of the block
        'name'      => 'flexible_block',
        // The location of the template
        'template'  => 'blocks.content-builder',
    ];
    
    public function init()
    {
        $this->getFieldsBuilder()
             ->setGroupConfig('title', 'Content Blocks')
             ->setLocation('post_type', '==', 'page');
                
        // This registers our ImageBlock as a child block of this flexible content layout
        $this->registerBlockType('ImageBlock');
    }
}
```

This flexible content block works exactly as any other block. To register it, modify the code you previously added to your functions.php (or equivalent) as follows:
```php
<?php
require_once('blocks/ImageBlock.php');
require_once('blocks/FlexibleBlock.php');

add_action('init', function() {
    $blocks = Blocks::getInstance();
    $blocks->init([
        'blocktypes' => [
            // array of block class names as strings
            'ImageBlock',
            'FlexibleBlock',
        ]
    ]);
});
```

Now, you will have a flexible content area on every Page where you can add the ImageBlock. The ImageBlock will also be added to template-image.php as a regular, non-flexible block.

## FAQ
**Will using this library have an impact on performance?**  
No, it's just a really thin layer of abstraction. It doesn't do much, it just allows you to write better code.

**I'm using [soberwp/controller](https://github.com/soberwp/controller) which already provides me with a Controller. Why should I use this library?**  
The concept behind soberwp/controller is great, but it has a few major drawbacks. It doesn't have any use in the context of flexible layouts. At the time of writing (Oct 7, 2017), it also has some architectural quirks such as the App controller being constructed twice. Also, inheritance doesn't really work properly so if you want to use the same field groups in multiple layouts, you'll end up stuffing almost all of the code in the main App controller.

**Actually, blocks aren't really Contollers..**  
No, they're much closer to View Models. However, using that term probably won't get the point across to many Wordpress devs.
